Introduction
	
Some grammars contain blind-alley rules, that is, grammar rules for which it is impossible to derive a string of terminal symbols. Blind-alley rules do not affect the language or parse trees generated by a grammar, so in some sense they don't make the answers wrong, but they're noise and they make grading harder. You'd like to filter out the noise, and just grade the useful parts of each grammar.


Definitions

fixed point
(of a function f) A point x such that f x = x. In this description we are using OCaml notation, in which functions always have one argument and parentheses are not needed around arguments.

computed fixed point
(of a function f with respect to an initial point x) A fixed point of f computed by calculating x, f x, f (f x), f (f (f x)), etc., stopping when a fixed point is found for f. If no fixed point is ever found by this procedure, the computed fixed point is not defined for f and x.

symbol
A symbol used in a grammar. It can be either a nonterminal symbol or a terminal symbol; each kind of symbol has a value, whose type is arbitrary. A symbol has the following OCaml type:
type ('nonterminal, 'terminal) symbol =
  | N of 'nonterminal
  | T of 'terminal

right hand side
A list of symbols. It corresponds to the right hand side of a single grammar rule. A right hand side can be empty.

rule
A pair, consisting of (1) a nonterminal value (the left hand side of the grammar rule) and (2) a right hand side.

grammar
A pair, consisting of a start symbol and a list of rules. The start symbol is a nonterminal value.


Review of code

First, In computed_fixed_point, my code computes the 
value of the given function with argument x twice if it is not at a fixed point.
I would have liked to have set a local variable, but I was not sure if that 
counted as a side effect. Second, my algorithm for filtering prioritizes valid
nonterminals (nonterminal symbols that eventually terminate to terminal symbols
via some set of rules) rather than valid rules (rules that lead to terminating
strings). I would have liked to keep track of valid rules and change up the
"good" rules to be returned as the final result. Instead, I check to see if
rules are good by looking for valid nonterminals after I have finished checking
for all the valid nonterminals. I tried my initial approach but encountered
errors with keeping track of the nonterminals and the good rules at once with
tuples. 

I found an interesting test case with regards to the set theory. I
didn't know that an empty set is a subset of all sets. This was a very important
piece of information to understand in order to move through the project. Also, I
considered the reachability of nonterminals initially in my grammar functions. 
This vastly complicated my algorithm until I realized it was an unnecessary
consideration.  

Algorithm for filter_blind_alleys (start_symbol, rules)
	list nterms = [] //list of valid nonterminals
	bool changed = false //flag for if nterms list was changed

	do
		changed = false
		for each rule do
			rule = (nterm, right_side)
			if( check_right_side (nterms, right_side) ) then 
//checks if all symbols in right_side are valid
				changed = true
				add(nterms, nterm) // adds the new item
to the list if it is not already present
			end
		done
	while (changed)

	list valid_rules = []
	for each rule do
		rule = (nterm, right_side)
		if( check_right_side (nterms, right_side)) then
			add(valid_rules,rule)
		end
	done
	return (start_symbol, valid_rules)

This algorithm runs in O(n^2) where n is the number of rules assuming the right 
hand side of a rule is << n.
